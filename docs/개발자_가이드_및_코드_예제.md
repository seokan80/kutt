# Kutt URL Shortener 개발자 가이드 및 코드 예제

## 개발 환경 설정

### 1. 필수 요구사항

```bash
# Node.js 20+ 설치 확인
node --version

# npm 패키지 설치
npm install

# 데이터베이스 마이그레이션
npm run migrate

# 개발 서버 시작
npm run dev
```

### 2. 환경 변수 설정

`.env` 파일 생성:

```env
# 기본 설정
PORT=3000
SITE_NAME=Kutt
DEFAULT_DOMAIN=localhost:3000
JWT_SECRET=your-super-secret-jwt-key-here

# 데이터베이스 설정
DB_CLIENT=better-sqlite3
DB_FILENAME=db/data

# Redis 설정 (선택사항)
REDIS_ENABLED=false

# 이메일 설정 (선택사항)
MAIL_ENABLED=false

# 보안 설정
DISALLOW_ANONYMOUS_LINKS=true
DISALLOW_REGISTRATION=true
ENABLE_RATE_LIMIT=true
```

## 핵심 컴포넌트 분석

### 1. 링크 핸들러 (`server/handlers/links.handler.js`)

#### 링크 생성 함수 예제

```javascript
const create = async (req, res, next) => {
  const { target, customurl, password, description, expire_in } = req.body;
  const { user } = req;

  try {
    // 1. 커스텀 URL 중복 확인
    if (customurl) {
      const existingLink = await query.link.find({ address: customurl });
      if (existingLink) {
        throw new CustomError("Custom URL already exists.", 400);
      }
    }

    // 2. 랜덤 주소 생성 또는 커스텀 주소 사용
    const address = customurl || generateShortId();

    // 3. 링크 데이터 구성
    const linkData = {
      address,
      target,
      description,
      password: password ? await bcrypt.hash(password, 10) : null,
      expire_in: expire_in ? new Date(expire_in) : null,
      user_id: user?.id || null,
      domain_id: req.body.domain_id || null,
    };

    // 4. 데이터베이스에 저장
    const link = await query.link.add(linkData);

    // 5. 캐시에 저장 (Redis 사용 시)
    if (redis.client) {
      await redis.client.setex(
        `link:${address}`,
        3600, // 1시간 TTL
        JSON.stringify(link)
      );
    }

    // 6. 응답 반환
    res.status(201).json({
      id: link.id,
      address: link.address,
      target: link.target,
      shortLink: `${env.DEFAULT_DOMAIN}/${link.address}`,
      created_at: link.created_at,
    });
  } catch (error) {
    next(error);
  }
};

// 단축 주소 생성 함수
function generateShortId() {
  const alphabet = env.LINK_CUSTOM_ALPHABET;
  const length = env.LINK_LENGTH;
  let result = '';
  
  for (let i = 0; i < length; i++) {
    result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
  }
  
  return result;
}
```

#### 리디렉션 함수 예제

```javascript
const redirect = async (req, res, next) => {
  const { id: address } = req.params;

  try {
    // 1. 캐시에서 링크 조회
    let link = null;
    if (redis.client) {
      const cached = await redis.client.get(`link:${address}`);
      if (cached) {
        link = JSON.parse(cached);
      }
    }

    // 2. 캐시 미스 시 데이터베이스에서 조회
    if (!link) {
      link = await query.link.find({ address });
      if (!link) {
        return res.status(404).render("404");
      }

      // 캐시에 저장
      if (redis.client) {
        await redis.client.setex(
          `link:${address}`,
          3600,
          JSON.stringify(link)
        );
      }
    }

    // 3. 만료 확인
    if (link.expire_in && new Date() > new Date(link.expire_in)) {
      return res.status(410).render("expired");
    }

    // 4. 비밀번호 보호 확인
    if (link.password) {
      return res.render("protected", { link });
    }

    // 5. 방문 통계 큐에 추가 (비동기)
    if (queue.visit) {
      await queue.visit.add("log-visit", {
        link_id: link.id,
        user_id: req.user?.id || null,
        ip: req.ip,
        user_agent: req.headers["user-agent"],
        referrer: req.headers.referer || "",
      });
    }

    // 6. 방문 횟수 증가
    await query.link.update({ id: link.id }, { 
      visit_count: link.visit_count + 1 
    });

    // 7. 리디렉션
    res.redirect(link.target);
  } catch (error) {
    next(error);
  }
};
```

### 2. 인증 핸들러 (`server/handlers/auth.handler.js`)

#### JWT 토큰 생성 예제

```javascript
const jwt = require("jsonwebtoken");
const bcrypt = require("bcryptjs");

const login = async (req, res, next) => {
  const { email, password } = req.body;

  try {
    // 1. 사용자 조회
    const user = await query.user.find({ email });
    if (!user) {
      throw new CustomError("Invalid credentials.", 401);
    }

    // 2. 비밀번호 검증
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      throw new CustomError("Invalid credentials.", 401);
    }

    // 3. 계정 상태 확인
    if (user.banned) {
      throw new CustomError("Account is banned.", 403);
    }

    if (!user.verified && env.MAIL_ENABLED) {
      throw new CustomError("Account is not verified.", 403);
    }

    // 4. JWT 토큰 생성
    const token = jwt.sign(
      { 
        id: user.id, 
        email: user.email, 
        role: user.role 
      },
      env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    // 5. 쿠키 설정
    res.cookie("token", token, {
      httpOnly: true,
      secure: env.NODE_ENV === "production",
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7일
    });

    // 6. 응답 반환
    res.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        verified: user.verified,
      },
    });
  } catch (error) {
    next(error);
  }
};
```

#### API 키 생성 예제

```javascript
const crypto = require("crypto");

const generateApiKey = async (req, res, next) => {
  const { user } = req;

  try {
    // API 키 생성
    const apikey = crypto.randomBytes(32).toString("hex");

    // 사용자 정보 업데이트
    await query.user.update({ id: user.id }, { apikey });

    res.json({ apikey });
  } catch (error) {
    next(error);
  }
};
```

### 3. 검증 미들웨어 (`server/handlers/validators.handler.js`)

#### 링크 생성 검증 예제

```javascript
const { body, validationResult } = require("express-validator");

const createLink = [
  body("target")
    .isURL({
      protocols: ["http", "https"],
      require_protocol: true,
    })
    .withMessage("Target must be a valid URL.")
    .isLength({ max: 2040 })
    .withMessage("Maximum URL length is 2040 characters."),

  body("customurl")
    .optional()
    .isLength({ min: 3, max: 50 })
    .withMessage("Custom URL must be between 3-50 characters.")
    .matches(/^[a-zA-Z0-9-_]+$/)
    .withMessage("Custom URL can only contain letters, numbers, hyphens, and underscores."),

  body("password")
    .optional()
    .isLength({ min: 6 })
    .withMessage("Password must be at least 6 characters long."),

  body("description")
    .optional()
    .isLength({ max: 500 })
    .withMessage("Description cannot exceed 500 characters."),

  body("expire_in")
    .optional()
    .isISO8601()
    .withMessage("Expiration date must be a valid ISO 8601 date.")
    .custom((value) => {
      if (new Date(value) <= new Date()) {
        throw new Error("Expiration date must be in the future.");
      }
      return true;
    }),
];
```

### 4. 데이터베이스 쿼리 (`server/queries/`)

#### 링크 쿼리 예제

```javascript
// server/queries/link.js
const knex = require("../knex");

const find = (match = {}) => {
  return knex("links")
    .where(match)
    .first();
};

const findMany = (match = {}, options = {}) => {
  const { limit = 50, offset = 0, orderBy = "created_at", order = "desc" } = options;
  
  return knex("links")
    .where(match)
    .orderBy(orderBy, order)
    .limit(limit)
    .offset(offset);
};

const add = async (data) => {
  const [id] = await knex("links").insert(data);
  return find({ id });
};

const update = (match, data) => {
  return knex("links")
    .where(match)
    .update({
      ...data,
      updated_at: new Date(),
    });
};

const remove = (match) => {
  return knex("links")
    .where(match)
    .del();
};

// 통계를 포함한 링크 조회
const findWithStats = (match) => {
  return knex("links")
    .leftJoin("visits", "links.id", "visits.link_id")
    .select(
      "links.*",
      knex.raw("COUNT(visits.id) as total_visits"),
      knex.raw("COUNT(DISTINCT visits.country) as unique_countries")
    )
    .where(match)
    .groupBy("links.id")
    .first();
};

module.exports = {
  find,
  findMany,
  add,
  update,
  remove,
  findWithStats,
};
```

## 미들웨어 개발 가이드

### 1. 인증 미들웨어

```javascript
// server/middleware/auth.js
const jwt = require("jsonwebtoken");
const query = require("../queries");

const authenticate = async (req, res, next) => {
  try {
    const token = req.cookies.token || req.headers.authorization?.replace("Bearer ", "");
    
    if (!token) {
      return res.status(401).json({ error: "Authentication required" });
    }

    const decoded = jwt.verify(token, env.JWT_SECRET);
    const user = await query.user.find({ id: decoded.id });

    if (!user || user.banned) {
      return res.status(401).json({ error: "Invalid or banned user" });
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: "Invalid token" });
  }
};

const requireAdmin = (req, res, next) => {
  if (req.user?.role !== "ADMIN") {
    return res.status(403).json({ error: "Admin access required" });
  }
  next();
};

module.exports = { authenticate, requireAdmin };
```

### 2. Rate Limiting 미들웨어

```javascript
// server/middleware/rateLimiter.js
const rateLimit = require("express-rate-limit");
const RedisStore = require("rate-limit-redis");
const redis = require("../redis");

const createRateLimiter = (options = {}) => {
  const {
    windowMs = 15 * 60 * 1000, // 15분
    max = 100, // 최대 요청 수
    message = "Too many requests, please try again later.",
  } = options;

  const limiterOptions = {
    windowMs,
    max,
    message: { error: message },
    standardHeaders: true,
    legacyHeaders: false,
  };

  // Redis가 활성화된 경우 Redis 스토어 사용
  if (redis.client) {
    limiterOptions.store = new RedisStore({
      sendCommand: (...args) => redis.client.call(...args),
    });
  }

  return rateLimit(limiterOptions);
};

// 특정 용도별 레이트 리미터
const authLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: "Too many authentication attempts, please try again later.",
});

const linkCreationLimiter = createRateLimiter({
  windowMs: 60 * 1000,
  max: 10,
  message: "Too many links created, please slow down.",
});

module.exports = {
  createRateLimiter,
  authLimiter,
  linkCreationLimiter,
};
```

## 큐 시스템 활용

### 1. 방문 통계 처리 큐

```javascript
// server/queues/visit.queue.js
const Queue = require("bull");
const redis = require("../redis");
const query = require("../queries");
const geoip = require("geoip-lite");
const useragent = require("useragent");

const visitQueue = new Queue("visit processing", {
  redis: redis.client ? redis.options : undefined,
});

// 방문 기록 처리 작업
visitQueue.process("log-visit", async (job) => {
  const { link_id, user_id, ip, user_agent, referrer } = job.data;

  try {
    // IP 해싱 (개인정보 보호)
    const crypto = require("crypto");
    const hashedIp = crypto
      .createHash("sha256")
      .update(ip + env.JWT_SECRET)
      .digest("hex");

    // 지리적 정보 추출
    const geo = geoip.lookup(ip);
    const country = geo?.country || "Unknown";

    // 브라우저 정보 추출
    const agent = useragent.parse(user_agent);
    const browser = agent.family;
    const os = agent.os.family;

    // 방문 기록 저장
    await query.visit.add({
      link_id,
      user_id,
      ip: hashedIp,
      country,
      referrer,
      browser,
      os,
      created_at: new Date(),
    });

    console.log(`Visit logged for link ${link_id}`);
  } catch (error) {
    console.error("Failed to log visit:", error);
    throw error;
  }
});

// 에러 처리
visitQueue.on("failed", (job, err) => {
  console.error(`Visit logging failed for job ${job.id}:`, err);
});

module.exports = visitQueue;
```

### 2. 이메일 발송 큐

```javascript
// server/queues/email.queue.js
const Queue = require("bull");
const nodemailer = require("nodemailer");
const redis = require("../redis");
const env = require("../env");

const emailQueue = new Queue("email processing", {
  redis: redis.client ? redis.options : undefined,
});

// SMTP 설정
const transporter = nodemailer.createTransporter({
  host: env.MAIL_HOST,
  port: env.MAIL_PORT,
  secure: env.MAIL_SECURE,
  auth: {
    user: env.MAIL_USER,
    pass: env.MAIL_PASSWORD,
  },
});

// 이메일 발송 작업
emailQueue.process("send-email", async (job) => {
  const { to, subject, html, text } = job.data;

  try {
    const info = await transporter.sendMail({
      from: env.MAIL_FROM,
      to,
      subject,
      text,
      html,
    });

    console.log(`Email sent: ${info.messageId}`);
    return info;
  } catch (error) {
    console.error("Failed to send email:", error);
    throw error;
  }
});

// 이메일 템플릿 함수들
const sendVerificationEmail = (email, token) => {
  const verificationUrl = `${env.DEFAULT_DOMAIN}/verify?token=${token}`;
  
  return emailQueue.add("send-email", {
    to: email,
    subject: "Verify your Kutt account",
    html: `
      <h2>Welcome to Kutt!</h2>
      <p>Please click the link below to verify your account:</p>
      <a href="${verificationUrl}">Verify Account</a>
      <p>This link will expire in 24 hours.</p>
    `,
    text: `Welcome to Kutt! Please verify your account: ${verificationUrl}`,
  });
};

const sendPasswordResetEmail = (email, token) => {
  const resetUrl = `${env.DEFAULT_DOMAIN}/reset-password?token=${token}`;
  
  return emailQueue.add("send-email", {
    to: email,
    subject: "Reset your Kutt password",
    html: `
      <h2>Password Reset Request</h2>
      <p>Click the link below to reset your password:</p>
      <a href="${resetUrl}">Reset Password</a>
      <p>This link will expire in 1 hour.</p>
    `,
    text: `Reset your password: ${resetUrl}`,
  });
};

module.exports = {
  emailQueue,
  sendVerificationEmail,
  sendPasswordResetEmail,
};
```

## 테스트 작성 가이드

### 1. 단위 테스트 예제

```javascript
// tests/handlers/links.test.js
const request = require("supertest");
const app = require("../../server/app");
const query = require("../../server/queries");

describe("Links Handler", () => {
  let authToken;
  let testUser;

  beforeEach(async () => {
    // 테스트 사용자 생성
    testUser = await query.user.add({
      email: "test@example.com",
      password: "hashedpassword",
      verified: true,
    });

    // 인증 토큰 생성
    authToken = jwt.sign({ id: testUser.id }, env.JWT_SECRET);
  });

  afterEach(async () => {
    // 테스트 데이터 정리
    await query.user.remove({ id: testUser.id });
  });

  describe("POST /api/links", () => {
    it("should create a new link", async () => {
      const linkData = {
        target: "https://example.com",
        customurl: "test123",
        description: "Test link",
      };

      const response = await request(app)
        .post("/api/links")
        .set("Authorization", `Bearer ${authToken}`)
        .send(linkData)
        .expect(201);

      expect(response.body).toHaveProperty("id");
      expect(response.body.target).toBe(linkData.target);
      expect(response.body.address).toBe(linkData.customurl);
    });

    it("should reject invalid URLs", async () => {
      const linkData = {
        target: "invalid-url",
      };

      await request(app)
        .post("/api/links")
        .set("Authorization", `Bearer ${authToken}`)
        .send(linkData)
        .expect(400);
    });

    it("should require authentication", async () => {
      const linkData = {
        target: "https://example.com",
      };

      await request(app)
        .post("/api/links")
        .send(linkData)
        .expect(401);
    });
  });

  describe("GET /:shortCode", () => {
    let testLink;

    beforeEach(async () => {
      testLink = await query.link.add({
        address: "test123",
        target: "https://example.com",
        user_id: testUser.id,
      });
    });

    it("should redirect to target URL", async () => {
      const response = await request(app)
        .get("/test123")
        .expect(302);

      expect(response.headers.location).toBe("https://example.com");
    });

    it("should return 404 for non-existent links", async () => {
      await request(app)
        .get("/nonexistent")
        .expect(404);
    });
  });
});
```

### 2. 통합 테스트 예제

```javascript
// tests/integration/auth.test.js
const request = require("supertest");
const app = require("../../server/app");

describe("Authentication Integration", () => {
  describe("User Registration and Login Flow", () => {
    const userData = {
      email: "integration@test.com",
      password: "testpassword123",
    };

    it("should complete full auth flow", async () => {
      // 1. 회원가입
      const signupResponse = await request(app)
        .post("/api/auth/signup")
        .send(userData)
        .expect(201);

      expect(signupResponse.body).toHaveProperty("message");

      // 2. 로그인
      const loginResponse = await request(app)
        .post("/api/auth/login")
        .send(userData)
        .expect(200);

      expect(loginResponse.body).toHaveProperty("token");
      expect(loginResponse.body.user.email).toBe(userData.email);

      // 3. 인증된 요청
      const protectedResponse = await request(app)
        .get("/api/user")
        .set("Authorization", `Bearer ${loginResponse.body.token}`)
        .expect(200);

      expect(protectedResponse.body.email).toBe(userData.email);
    });
  });
});
```

## 성능 최적화 팁

### 1. 데이터베이스 최적화

```javascript
// 인덱스 추가 마이그레이션 예제
exports.up = function(knex) {
  return knex.schema.table("links", (table) => {
    table.index("address"); // 단축 URL 조회 최적화
    table.index("user_id"); // 사용자별 링크 조회 최적화
    table.index(["user_id", "created_at"]); // 복합 인덱스
  });
};

// 효율적인 쿼리 예제
const getUserLinksWithStats = async (userId, options = {}) => {
  const { limit = 20, offset = 0 } = options;
  
  return knex("links")
    .leftJoin("visits", "links.id", "visits.link_id")
    .select(
      "links.*",
      knex.raw("COUNT(visits.id) as visit_count"),
      knex.raw("MAX(visits.created_at) as last_visit")
    )
    .where("links.user_id", userId)
    .groupBy("links.id")
    .orderBy("links.created_at", "desc")
    .limit(limit)
    .offset(offset);
};
```

### 2. 캐싱 전략

```javascript
// 캐시 헬퍼 함수
const cache = {
  get: async (key) => {
    if (!redis.client) return null;
    const data = await redis.client.get(key);
    return data ? JSON.parse(data) : null;
  },

  set: async (key, data, ttl = 3600) => {
    if (!redis.client) return;
    await redis.client.setex(key, ttl, JSON.stringify(data));
  },

  del: async (key) => {
    if (!redis.client) return;
    await redis.client.del(key);
  },
};

// 캐시 적용 예제
const getLinkWithCache = async (address) => {
  const cacheKey = `link:${address}`;
  
  // 캐시에서 조회
  let link = await cache.get(cacheKey);
  
  if (!link) {
    // 데이터베이스에서 조회
    link = await query.link.find({ address });
    
    if (link) {
      // 캐시에 저장 (1시간)
      await cache.set(cacheKey, link, 3600);
    }
  }
  
  return link;
};
```

## 보안 모범 사례

### 1. 입력 검증 및 정제

```javascript
const sanitizeInput = (req, res, next) => {
  // HTML 태그 제거
  if (req.body.description) {
    req.body.description = req.body.description.replace(/<[^>]*>/g, "");
  }
  
  // URL 정규화
  if (req.body.target) {
    try {
      const url = new URL(req.body.target);
      req.body.target = url.toString();
    } catch (error) {
      return res.status(400).json({ error: "Invalid URL format" });
    }
  }
  
  next();
};
```

### 2. 보안 헤더 설정

```javascript
const helmet = require("helmet");

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
  },
}));
```

이 개발자 가이드는 Kutt URL Shortener 프로젝트의 핵심 컴포넌트와 개발 패턴을 실제 코드 예제와 함께 설명합니다. 이를 통해 개발자들이 프로젝트를 이해하고 기능을 확장할 수 있도록 도움을 제공합니다.